# Goroutine

## Processes and Threads

- 进程：操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程。
- 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

- 协程：协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

## Goroutines and Parallelism
GO 语言自身支持协程实现，在语言中的表现为Goroutine

Go 语言层面支持的 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为 goroutine 执行的。操作系统调度线程在可用处理器上运行，Go运行时调度 goroutines 在绑定到单个操作系统线程的逻辑处理器中运行(P)。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万 goroutine 以惊人的效率和性能并发运行。
~~~go
go func() {
    //todo 
}()
~~~

**Concurrency is not Parallelism.**

并发并不是并行：

并行是指两个或多个线程同时在不同的处理器执行代码。如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配 goroutine，这将导致 goroutine 在不同的操作系统线程上运行。但是，要获得真正的并行性，您需要在具有多个物理处理器的计算机上运行程序。否则，goroutines 将针对单个物理处理器并发运行，即使 Go 运行时使用多个逻辑处理器。

而并发是通过调度算法处理，使单个CPU在不同的时间片中处理不同的线程（协程）程序，也就是时间管理大师——罗某

## 管住 Goroutine 的生命周期

### Keep yourself busy or do the work yourself.
在main goroutine退出后，所有的程序都会退出,所以为了阻塞main goroutine，有时候会做点骚操作！
~~~go
func main() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, "Hello, GopherCon SG")
	})
	go func() {
		// 是否会出错，main goroutine 感知不到，也处理不了。
		if err := http.ListenAndServe(":8080", nil); err != nil {
			log.Fatal(err) // Fatal() 底层调用了 os.Exit()当报错直接退出
		}
	}()
	select { // 永远阻塞。
	}
}
~~~
* ❌ `go` 一个 goroutine 去 `ListenAndServe`，main 使用 `select{}` 阻塞。

main goroutine 会阻塞，无法处理别的事情，即使 `ListenAndServe` 的 goroutine 出了错，
它也不会得知，也无法处理，两个 goroutine 之间缺少通讯机制。
### Never start a goroutine without knowing when it will stop
当启动一个 goroutine 时，要明确两个问题：
- 它什么时候会结束（terminate）？
- 它要怎样结束，要达到什么样的条件，怎么让它退出？


查看下列案例：
尝试在两个不同的端口上提供 http 流量：8080 用于应用程序流量；8081 用于访问 /debug/pprof 端点。
~~~go
func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Request) {
		fmt.Fprintln(resp, "Hello, QCon!")
	})
	// ↓ 如果不使用 go，会阻塞在这一行，再下一行的 ListenAndServe 就没有机会执行
	//   但这里启动后不管了，这种做法是不好的，应该管理 goroutine 的结束。启动者要对 goroutine 的生命周期负责。
	go http.ListenAndServe("127.0.0.1:0801", http.DefaultServeMux)
	http.ListenAndServe("0.0.0.0:8080", mux)
}
~~~
这个例子有什么问题呢？
- 启动的 goroutine 是否成功、出错，主 goroutine 完全无法得知，
- 主 goroutine 也因用于监听服务阻塞，没有能力处理其他事务。

把处理流程写在主函数也太丑了吧！我们把两个提出来，然后再用`go`出去，再想办法阻塞主函数：
~~~go
func serveApp() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Request) {
		fmt.Fprintln(resp, "Hello, QCon!")
	})
	if err := http.ListenAndServe("0.0.0.0:8080", mux); err != nil {
		log.Fatal(err)
	}
}

func serveDebug() {
	if err := http.ListenAndServe("127.0.0.1:8001", http.DefaultServeMux); err != nil {
		log.Fatal(err)
	}
}

func main() {
	go serveDebug()
	go serveApp()
	select {}
}
~~~
这个看起来好像简洁了很多了，但是问题来了是不是跟第一个差不多，都是没有出错的处理而且还犯了一点：Only use log.Fatal from main.main or init functions

我们期望使用一种方式，同时启动业务端口和 debug 端口，如果任一监听服务出错，应用都退出。
此时，当当当当，channel 闪亮登场！！！！！！
~~~go
func serve(addr string, handler http.Handler, stop <-chan struct{}) error {
	s := http.Server{
		Addr:    addr,
		Handler: handler,
	}
	go func() {
		<-stop // wait for stop signal
		s.Shutdown(context.Background())
	}()
	return s.ListenAndServe()
}
func serveApp(stop <-chan struct{}) error {
	mux := http.NewServeMux()
	mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Request) {
		fmt.Fprintln(resp, "Hello, QCon!")
	})
	return serve("0.0.0.0:8080", mux, stop)
}
func serveDebug(stop <-chan struct{}) error {
	return serve("127.0.0.1:8081", http.DefaultServeMux, stop)
}

func main() {
	done := make(chan error, 2)
	stop := make(chan struct{})
	go func() {
		done <- serveDebug(stop)
	}()
	go func() {
		done <- serveApp(stop)
	}()
	// serveApp、serveDebug 任意一个出错，都会解除 <-done的阻塞
	// close(stop) 会广播解除所有 <-stop 的阻塞，没有出错的监听也会被 shutdown
	var stopped bool
	for i := 0; i < cap(done); i++ { // 循环两次是为了等所有的 server 平滑安全退出
		if err := <-done; err != nil {
			fmt.Printf("error: %v\n", err)
		}
		if !stopped {
			stopped = true
			close(stop)
		}
	}

}
~~~

如果这个时候再有一个 goroutine 可以向 stop 传入一个 struct{}，就可以控制整个进程平滑停止。这里可以参见[go-workgroup](https://github.com/da440dil/go-workgroup)
## 把并发扔给调用者