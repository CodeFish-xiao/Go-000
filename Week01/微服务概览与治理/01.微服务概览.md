# 微服务概览

## 为什么会有微服务
在业务量比较小的时候，基本上大家都是从单体架构开始的，springMVC啊，beego啊，gin啊，都是单体架构的一些常见框架，尽管也有分层，分模块开发，但是最终它还是会打包并部署为单体式应用。就如下图所示：
![单体巨石架构](./img/01.MonomerArchitecture.png)
随着业务慢慢起来，模块越来越多，问题就出来了：
- 其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能搞懂它。
- 应用无法扩展，可靠性很低，最终，敏捷性开发和部署变的无法完成。

那我们要怎么去应对呢？
- 化繁为简，分而治之 
把这一大坨的巨石架构的东西按照一定的划分（可以是业务，可以是资源，也可以参照DDD设计）拆分成一个个微服务去进行处理，每个服务各司其职，其他想用你这个服务的东西就去调你的接口，然后再把最终的接口暴露给客户端，让整个开发变得舒服起来。
![微服务](./img/01.DistributedArchitecture.png)

## 微服务起源
先讲个概念：**SOA**（面向服务的架构）：  
面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和协议联系起来。
![两种架构对比](./img/01.ContrastTheTwoArchitectures.png)
而微服务呢？就是SOA思想的一种实践。你应该把微服务看作是SOA的一种特定方法，就像XP或Scrum是敏捷软件开发的特定方法一样。
- 小即是美：小的服务代码少，bug 也少，易测试，易维护，也更容易不断迭代完善的精致进而美妙。
- 单一职责：一个服务也只需要做好一件事，专注才能做好。
- 尽可能早地创建原型：尽可能早的提供服务 API，建立服务契约，达成服务间沟通的一致性约定，至于实现和完善可以慢慢再做。
- 可移植性比效率更重要：服务间的轻量级交互协议在效率和可移植性二者间，首要依然考虑兼容性和移植性。

## 微服务定义

围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。

微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活。

优点：
- 服务拆分后比较小，BUG 少，容易测试和维护，也容易扩展
- **原子服务**，一个服务只做一件事情，并且这个属于这个服务的也不应该拆分到其他服务去
- **独立进程**，一个服务只有一个独立进程，可以很好的和当前的容器化进行结合，无状态的服务可以很容易的享受到，k8s 上的故障转移，自动重启等好处
- **隔离部署**，每个服务之间独立部署，可以避免相互影响，并且和按需进行分配资源，节省成本
- **去中心化服务治理**
  - 数据去中心化，每个服务独享数据库，缓存等设施，也有个别情况多个服务共享数据库，例如面向用户的管理后台和面向管理员的管理后台
  - 治理去中心化
  - 技术去中心化，每个服务可以使用适合自己的技术进行实施，但是注意如果技术栈过于发散对于企业或者团队本身也是不利的

缺点：
- **服务之间的依赖关系复杂**，成千上万个服务相互依赖就像一团乱麻一样，剪不断理还乱。
  - 常见的解决方案：全链路追踪，例如， opentracing
- 微服务本身是分布式系统，需要使用 RPC 或者 消息进行通信，此外，**必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题**
  - 例子：服务调用流量会容易被放大，如果 服务 A -> B ->C 如果 A 有一个循环调用 B，B 也有一个循环调用 C，那么一个请求到达 C 之后就被放大了 100 倍甚至上千倍。这是扛不住的
  - **常见解决方案：粗粒度的进程间通信（batch 接口，批量请求，避免 n+1 问题），隔离，超时保护，负载保护，熔断、限流、降级、重试，负载均衡**
- 会有**分布式事务问题**，因为现在每个微服务之间都会有一个独立的数据库，事务在单体应用中很好处理，但是在跨服务时会变得很麻烦
  - 常见解决方案：两阶段提交、TCC 等
- 测试会非常复杂，由于依赖多，无法得知是因为功能异常还是依赖的某个服务发版出现问题
  - 多租户可解决（看后面）
- 服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。
  - 切记，在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约(接口)的兼容性
  - 发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。
- 对**基础建设的要求很高**，基础设施需要自动化，日志采集，监控数据采集，告警，CICD，K8s 等
  - 常见解决方案：上云，花钱能解决的问题永远不是问题！！

## 组件服务化（怎么构建微服务）
传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。 通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。我们用 Go 实施一个微服务需要哪些实现呢？

- **kit：一个微服务的基础库(框架)。**：要基于统一的基础库进行开发，防止重复造轮子
- **service**：业务代码 + kit 依赖 + 第三方依赖组成的业务微服务
- **rpc + message queue：轻量级通讯**：之前有使用消息总线（ESB）进行开发的架构（如下图），将所有的消息传递通过消息总线进行传递，违背了去中心化原则，所以要选择轻量级的rpc或者restful接口通讯

![ESB架构](./img/01.ESBArchitecture.png)


其实在本质上，原本一个大架构的事情变成了多个微服务组合(compose)完成了一个完整的用户场景(usecase)。

## 软件架构对应人员组织架构

一般来说，可以先按照业务去划分微服务，也就是按照业务能力去组织服务，比如在真实场景中，一般就是将订单，账户分为服务，而不会再将数据访问单独开个服务。前者反应了真实的相关业务，后者是一种技术抽象服务不反应真实的业务。所以按微服务架构理念来划分服务时，是不应该存在数据访问服务这样一个服务的。

当划分服务后，就可以分成一个个小的开发团队，对每个服务进行全方位保障，在传统垂直应用结构中，一般就是前端，后端，数据库开发完就都交给运维测试，然后有问题再说。

![垂直结构人员交流](./img/01.VerticalApplications.png)

所以若要按微服务的方式来构建应用，也需要对应调整团队的组织架构。每个服务背后的小团队的组织是跨功能的，包含实现业务所需的全面的技能。

某互联网公司的交流结构如下：大前端(移动/Web) =》 网关接入 =》业务服务 =》平台服务 =》基础设施(PaaS/Saas)
在这种交流下：开发团队对软件在生产环境的运行负全部责任！
每个模块的只需要跟自己的调用方和被调用方交流即可，开发人员自己完成对于服务的部署，单元测试，对自己的服务负责。

![微服务交流场景](./img/01.MicroserviceExchange.png)

## 基础设施自动化
微服务会带来对于基础服务的挑战，单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。

- CICD：Gitlab + Gitlab Hooks + k8s
- Testing：测试环境、单元测试、API自动化测试
- 在线运行时：k8s，以及一系列 Prometheus、ELK、Conrtol Panle


![CICD图示](./img/01.CICD.png)


## 可用性 & 兼容性设计

在设计微服务的时候要注意：哪里都可能会炸，著名的 Design For Failure 思想，要想着在设计的时候想到一堆会炸的点，而不是炸了才去想我靠哪里炸了。

微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略其中任何一点都属于对“分布式计算的误解”。

一般在微服务中要注意下面这些点：

- 隔离
- 超时控制
- 负载保护 
- 限流
- 降级
- 重试
- 负载均衡

一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约(接口)的兼容性。

设计接口时要遵循这个约定：
**发送时要保守，接收时要开放**。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。


上一节：无
下一节：[微服务设计](./02.微服务设计.md)